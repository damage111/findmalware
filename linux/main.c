#include "customScan.h"
#include "httpApi.h"
#include "getIp.h"
#include <stdio.h>
#include <sys/time.h>
#include <time.h>
#include "ssllib.h"
#include <fcntl.h>
#include <semaphore.h>
#include "procInfo.h"
#include "cJSON.h"
#include "healthMontior.h"

extern int g_virusCount;
extern int g_packedCount;
extern int g_scanCount;
extern int g_cleanedCount;
extern int g_c_virusCount;
extern int g_c_packedCount;
extern int g_c_scanCount;
extern int g_c_cleanedCount;

int g_clean_type=2;
int g_virus_size;
char g_virus_hash[50]={""};
char g_virus_name[20]={""};
char g_blacklist[2]={""};
char g_startType[20]={""};
char g_attackType[20]={""};
char g_os_version[260]={""};
char *g_os_type="Linux64";
char *g_pass="5gPvM47i&iQ3TuSL";
char *version="ACM Cloud Engine/F2M ver1.0";
char g_client_ip[64]={""};
int g_client_pid;
char g_client_starttime[20]={""};
void printHelp(){
	printf("\n");
	printf("*********************************************************\n");
	printf("*                                                       *\n");
	printf("* %s                 *\n",version);
	printf("* Process Scan -> Input [1]                             *\n");
	printf("* Custom  Scan -> Input [2]                             *\n");
	printf("*                                                       *\n");
	printf("*********************************************************\n");
}

void printResult(double duration,int scanCount,int virusCount ,int packed,int cleaned){
	printf("--------------- Scan completed successfully ----------------\n");
	printf("Scan completed in %f seconds, %f ms/file.\n", duration, (duration/scanCount)*1000);
	printf("Number of scanned  objects: %d\n",scanCount);
	printf("Number of infected objects: %d\n",virusCount);
	printf("Number of Packed   objects: %d\n",packed);
	printf("Number of cleaned  objects: %d\n",cleaned);
}

//程序监控函数
void appMontior(int startBeat,int endBeat,
                int resStat,char* cpuUsage,char* memRss,
                int errorLog,char* clientErrorType,char* clientErrorDetail,char* lastClientIp,int lastClientPid,char* lsatClientStarttime
                )
{
    int reportRetryTimes=0;
    cJSON *monReportJsonRoot, *monReportArray ,*monReportObject;
    monReportJsonRoot = cJSON_CreateObject();
    cJSON_AddStringToObject(monReportJsonRoot, "type", "montiorReport"); //监控日志  
    cJSON_AddNumberToObject(monReportJsonRoot, "startBeat", startBeat); //开始心跳
    cJSON_AddNumberToObject(monReportJsonRoot, "endBeat", endBeat);  //结束心跳
    cJSON_AddNumberToObject(monReportJsonRoot, "resStat", resStat); //cpu 内存状态
    cJSON_AddStringToObject(monReportJsonRoot, "cpuUsage", cpuUsage); //cpu占用
    cJSON_AddStringToObject(monReportJsonRoot, "memRss", memRss); //当前使用物理内存 
    cJSON_AddStringToObject(monReportJsonRoot, "clientIp", g_client_ip); //客户端ip
    cJSON_AddNumberToObject(monReportJsonRoot, "clientPid", g_client_pid); //进程pid 
    cJSON_AddStringToObject(monReportJsonRoot, "clientStartime", g_client_starttime);
    cJSON_AddStringToObject(monReportJsonRoot, "appVersion", version); //程序版本
    cJSON_AddStringToObject(monReportJsonRoot, "osPlatform", g_os_type); //操作系统版本
    cJSON_AddStringToObject(monReportJsonRoot, "osVersion", g_os_version); //os环境
    char buf[128]={""};
    strcat(buf,g_client_ip);
    strcat(buf,g_client_starttime);
    char pid[10]={""};
    if(g_client_pid<99999999){
    	sprintf(pid,"%d",g_client_pid);
    }else{
    	exit(0);
    }
    
    strcat(buf,pid);
    strcat(buf,g_pass);
    int hash_size=33;
    char *md5hash = malloc(hash_size*(sizeof(char)));
    if(md5hash == NULL) return 0;
    memset(md5hash,0,hash_size*sizeof(char)); //初始化为0
    getStringmd5(buf,md5hash);
    
    cJSON_AddStringToObject(monReportJsonRoot, "token", md5hash);
    
    if(errorLog!=1){
        cJSON_AddItemToObject(monReportJsonRoot, "lastRunstat", monReportArray=cJSON_CreateArray());//本地日志
        cJSON_AddItemToArray(monReportArray,monReportObject=cJSON_CreateObject());
        cJSON_AddStringToObject(monReportObject, "clientErrorType", clientErrorType);//上次运行错误类型
        cJSON_AddStringToObject(monReportObject, "clientErrorDetail", clientErrorDetail);//上次运行错误详情
        cJSON_AddStringToObject(monReportObject, "lastClientIp", lastClientIp); //上次运行客户端ip
        cJSON_AddNumberToObject(monReportObject, "lastClientPid", lastClientPid); //上次运行pid
        cJSON_AddStringToObject(monReportObject, "lsatClientStarttime", lsatClientStarttime); //上次运行时间
    }

    char *monReportStr=cJSON_Print(monReportJsonRoot);
    int monReportResult=reportJsonBody(monReportStr,3); //3代表时监控日志上报
    while(monReportResult==0){  //超时重发
        sleep(1);
        monReportResult=reportJsonBody(monReportStr,3);
        reportRetryTimes++;
    }
    free(monReportStr);
    free(md5hash);

    //sleep(1);
    cJSON_Delete(monReportJsonRoot);

}

//获取当前unix时间戳
int get_curr_unixtime(void)
{
    time_t now;
    int unixtime = time(&now);
    return unixtime;
}

int main(int argc,char **argv){
    int curr_memRss=0;
	sem_t *sem;
	sem = sem_open("/findmalware", O_CREAT, 0644, 0);
	if(sem == SEM_FAILED)
    {
        perror("unable to create semaphore");
        sem_close(sem);
		sem_unlink("/findmalware");
        exit(-1);
    }
	if (argc<2){
		printf("param error!\n");
		exit(0);
	}else{
		if(strlen(argv[1])>20){
			printf("param error!\n");
			exit(0);
		}
		int paramSize=20; 
		char *paramData = malloc(paramSize*(sizeof(char)));
		if(paramData == NULL) return 0;
		memset(paramData,0,paramSize*sizeof(char)); //初始化为0
		strcat(paramData,argv[1]);
		
        //检查参数
		if(strstr(paramData,",")){
			int in=0;
			char *p[20];
			char *buf=paramData;
			char *outer_ptr=NULL;
			while((p[in] = strtok_r(buf, ",", &outer_ptr))!=NULL)
			{
				buf=p[in];
				in++;
				buf=NULL;
			}
			int j;
			for (j=0; j<in; j++)
			{
				if(j==0){
					strcat(g_startType,p[j]);
				}
				if(j==1){
					strcat(g_attackType,p[j]);
				}
			}
		}else{
			strcat(g_startType,paramData);
			strcat(g_attackType,"procScan");
		}
		free(paramData);
	}
    
    //当前unix时间
    int curr_unixtime=get_curr_unixtime();
    if(curr_unixtime<2533924548){
    	sprintf(g_client_starttime,"%d",curr_unixtime);
    }else{
    	exit(0);
    }

    //获取当前pid
    pid_t curr_pid = getpid();
    g_client_pid=curr_pid;
    
    //操作系统版本
	int version_size=260;
	char *os_version = malloc(version_size*(sizeof(char)));
	if(os_version == NULL) return 0;
	memset(os_version,0,version_size*sizeof(char)); //初始化为0
	getOS_Version(os_version);
	strncpy(g_os_version,os_version,strlen(os_version));
	free(os_version);
    
    //程序计时timer
	struct timeval starttime,endtime;
	gettimeofday(&starttime,0);
    
    //本地ip
	char *local_ip;
	local_ip = get_ip();
	strncpy(g_client_ip,local_ip,strlen(local_ip));
	free(local_ip);
    
    //监控参数
    int startBeat=0;
    int endBeat=0;
    int resStat=1; //1表示正常
    char cpuUsage[10]={""};
    char memRss[10]={""};
    int errorLog=1;
    char clientErrorType[10]={""};
    char clientErrorDetail[64]={""};
    char lastClientIp[128]={""};
    int lastClientPid=0;
    char lsatClientStarttime[32]={""};
    
    //发送第一个心跳包
    startBeat=1;
    appMontior(startBeat,endBeat,
               resStat,cpuUsage,memRss,
               errorLog,clientErrorType,clientErrorDetail,lastClientIp,lastClientPid,lsatClientStarttime
               );
    //进程扫描开始运行
	printf("---------------------- Process scan ----------------------\n");
	procScan();
    
    //程序timer结束
	gettimeofday(&endtime,0);
	double timeuse = 1000000*(endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
	timeuse /=1000000;
    
    //上报扫描结果
	int v_count=g_virusCount+g_packedCount;
	char buf[512]={""};
	strcat(buf,g_client_ip);
	strcat(buf,version);
	strcat(buf,g_pass);
	int hash_size=33;
	char *md5hash = malloc(hash_size*(sizeof(char)));
	if(md5hash == NULL) return 0;
	memset(md5hash,0,hash_size*sizeof(char)); //初始化为0
	//获取cpu使用率
    int cpu_number = ALL_CPUS;
    pid_stat_fields pid_start, pid_stop;
    cpu_stat_fields cpu_start, cpu_stop; 
    pid_start = get_pid_stat_monitor();
    cpu_start = get_cpu_stat_monitor(cpu_number);
  
	getStringmd5(buf,md5hash);
	
	int flag=scanReport(v_count,g_cleanedCount,g_client_ip,timeuse,g_attackType,version,g_os_type,g_os_version,g_startType,md5hash);
	
    //超时重发，秒单位
	while (flag==0){
		sleep(3);
		flag=scanReport(v_count,g_cleanedCount,g_client_ip,timeuse,g_attackType,version,g_os_type,g_os_version,g_startType,md5hash);
	}
    
    
    //打印扫描结果
	printResult(timeuse,g_scanCount,v_count,g_packedCount,g_cleanedCount);
	
    pid_stop = get_pid_stat_monitor();
    cpu_stop = get_cpu_stat_monitor(cpu_number);  
    float percent_usage = pid_cpu_usage_percent(pid_start, pid_stop, cpu_start, cpu_stop);
    sprintf(cpuUsage,"%.2f%",percent_usage);
    cpu_usage_stats(cpu_start, cpu_stop);
    

    //释放内存
	free(md5hash);
	sem_close(sem);
	sem_unlink("/findmalware");
	
    //获取内存
    curr_memRss=get_curr_memRss(g_client_pid);
    if(curr_memRss<10240000){
    	sprintf(memRss,"%d",curr_memRss);
    }else{
    	exit(0);
    }
    
    //发送程序结束心跳包
    startBeat=0;
    endBeat=1;
    appMontior(startBeat,endBeat,
               resStat,cpuUsage,memRss,
               errorLog,clientErrorType,clientErrorDetail,lastClientIp,lastClientPid,lsatClientStarttime
               );
	
    //getchar();
	return 1;
}