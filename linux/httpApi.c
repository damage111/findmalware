#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <curl/easy.h>
#include "httpApi.h"
#include "cJSON.h"
char *useragent="ACM Cloud Engine/F2M Agent Ver1.0";


char *queryVirusApi="http://123.56.82.83/query_virus.php";
char *insertVirusApi="http://123.56.82.83/mal_zombie_repo.php";
char *reportHashApi="http://123.56.82.83/mal_hash_repo.php";
char *scanReportApi="http://123.56.82.83/mal_scan_repo.php";
char *monitorApi="http://123.56.82.83/mal_monitor.php";
char *taobaoIpApi="http://ip.taobao.com/service/getIpInfo2.php";

int timeout=20;
int timeout_times=0;
int retrytimes=20;
extern char g_virus_hash[50];
extern char g_virus_name[20];
extern char g_blacklist[2];
extern char g_client_ip[64];

struct MemoryStruct {
  char *memory;
  size_t size;
};


///

static size_t
WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
  size_t realsize = size * nmemb;
  struct MemoryStruct *mem = (struct MemoryStruct *)userp;
 
  mem->memory = realloc(mem->memory, mem->size + realsize + 1);
  if(mem->memory == NULL) {
    /* out of memory! */ 
    printf("not enough memory (realloc returned NULL)\n");
    return 0;
  }
 
  memcpy(&(mem->memory[mem->size]), contents, realsize);
  mem->size += realsize;
  mem->memory[mem->size] = 0;
 
  return realsize;
}
 

//////////////////////////////////////////////////////////////////////////
/* Parse text to JSON, then render back to text, and print! */
//int doit(char *file_hash_temp,char *virus_size,int virus_size_size,char *virus_hash,int virus_hash_size,char *virus_name,int virus_name_size,char *blacklist,int blacklist_size)//,char * s_size,char * s_md5,char * v_name)
int doit(char *text)
{
	cJSON * root;
	cJSON * format;
	char * state;
	if(text==NULL){
		return 0;
	}
	root = cJSON_Parse(text); 
	state = cJSON_GetObjectItem(root,"state")->valuestring;
	char *temp_size;
	char *temp_hash;
	char *temp_name;
	char *temp_kill;
	if (strcmp(state,"success")==0)
	{	
		temp_hash = cJSON_GetObjectItem(root,"file_hash")->valuestring;
		strncpy(g_virus_hash,temp_hash,sizeof(g_virus_hash));
		temp_name = cJSON_GetObjectItem(root,"virusname")->valuestring;
		strncpy(g_virus_name,temp_name,sizeof(g_virus_name));
		temp_kill = cJSON_GetObjectItem(root,"blacklist")->valuestring;
		strncpy(g_blacklist,temp_kill,sizeof(g_blacklist));
		printf("Found Virus:%s:%s\n", temp_hash,temp_name);
		cJSON_Delete(root);
		return 1;
	}else{
		printf("%s\n",state);
	}
	cJSON_Delete(root);
	return 0;
}



//////post
int query_virus2(char* section_hash,char *token)
{
  CURL *curl;
  CURLcode res2;
  struct MemoryStruct chunk2;
  chunk2.memory=(char*)malloc(1);
  chunk2.size = 0;    /* no data at this point */ 
  /* In windows, this will init the winsock stuff */ 
  curl_global_init(CURL_GLOBAL_ALL);
  int result=0;
  /* get a curl handle */ 
  curl = curl_easy_init();
  struct curl_slist *list = NULL;
  if(curl) {
	
	int data_size=512;
	char *postdata = malloc(data_size*(sizeof(char)));
	if(postdata == NULL) return 0;
	memset(postdata,0,data_size*sizeof(char)); //初始化为0
	strcat(postdata,"{\"section_hash\":\"");
	strcat(postdata,section_hash);
	strcat(postdata,"\",\"platform\":\"linux");
	strcat(postdata,"\",\"token\":\"");
	strcat(postdata,token);
	strcat(postdata,"\"}");
	int datalen=strlen(postdata);
	char len1[1024]={""};
	sprintf(len1,"%d",datalen);
	list = curl_slist_append(NULL, "Content-Type: application/json; charset=UTF-8");
	char templen[1024]={""};
	char *temp="Content-Length: ";
	strcat(templen,temp);
	strcat(templen,len1);
	curl_slist_append(list,templen);
	if(list == NULL)
	{
	   free(postdata);
	   curl_easy_cleanup(curl);
	   return 0;
   }
	curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
	curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
	
	//CURLOPT_HEADER, 1
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);

   
    curl_easy_setopt(curl, CURLOPT_URL, queryVirusApi);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
  	
	
	curl_easy_setopt(curl, CURLOPT_POST, 1L);
	
    
	/* timeout */	
	curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);
	
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
	/* send all data to this function  */ 
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    /* we pass our 'chunk' struct to the callback function */ 
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
    /* some servers don't like requests that are made without a user-agent
    field, so we provide one */ 
    curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);
	
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);
    /* Perform the request, res will get the return code */ 
    res2 = curl_easy_perform(curl);
    /* Check for errors */ 

	if(res2 != CURLE_OK){
		
		fprintf(stderr,curl_easy_strerror(res2));
		timeout_times++;
		printf(",reconnected %d times\n",timeout_times);
		if(timeout_times>retrytimes){
			free(postdata);
			curl_easy_cleanup(curl);
			curl_global_cleanup();
			printf("Connected to ACM cloud engine failed,please check the network connection... \n");
			exit(0);
		}
		result=-1;
	}else{
		char * file_hash_temp =chunk2.memory;
		//printf("%s\n",file_hash_temp);
		if (doit(file_hash_temp)==1)
		{
			result=1;
		}else{
			result=0;
		}
		
	} 
	free(postdata);
	curl_slist_free_all(list); /* free the list again */
  }
 
  curl_easy_cleanup(curl);
  if(chunk2.memory)
	  free(chunk2.memory);
  curl_global_cleanup();
  return result;
}

////
int insertVirus(char* virus_name,char* section_hash,char* section_size,char* virus_path,char* remote_ip,char* client_ip,char* killed,char *virus_id,char *start_type,char *token)
{
  CURL *curl;
  CURLcode res2;
  int result=0;
  struct MemoryStruct chunk2;
  chunk2.memory=(char*)malloc(1);
  chunk2.size = 0;    /* no data at this point */ 
  /* In windows, this will init the winsock stuff */ 
  curl_global_init(CURL_GLOBAL_ALL);
 
  /* get a curl handle */ 
  curl = curl_easy_init();
  struct curl_slist *list = NULL;
  if(curl) {
	int data_size=1024;
	char *postdata = malloc(data_size*(sizeof(char)));
	if(postdata == NULL) return 0;
	memset(postdata,0,data_size*sizeof(char)); //初始化为0
	strcat(postdata,"{\"virus_name\":\"");
	strcat(postdata,virus_name);
	strcat(postdata,"\",\"section_hash\":\"");
	strcat(postdata,section_hash);
	strcat(postdata,"\",\"section_size\":\"");
	strcat(postdata,section_size);
	strcat(postdata,"\",\"virus_path\":\"");
	strcat(postdata,virus_path);
	strcat(postdata,"\",\"remote_ip\":\"");
	strcat(postdata,remote_ip);
	strcat(postdata,"\",\"client_ip\":\"");
	strcat(postdata,client_ip);
	strcat(postdata,"\",\"killed\":\"");
	strcat(postdata,killed);
	strcat(postdata,"\",\"virus_id\":\"");
	strcat(postdata,virus_id);
	strcat(postdata,"\",\"start_type\":\"");
	strcat(postdata,start_type);
	strcat(postdata,"\",\"token\":\"");
	strcat(postdata,token);
	strcat(postdata,"\"}");
//	printf("%s\n",postdata);
	  
	int datalen=strlen(postdata);
	char len1[1024]={""};
	sprintf(len1,"%d",datalen);
	list = curl_slist_append(NULL, "Content-Type: application/json; charset=UTF-8");
	char templen[1024]={""};
	char *temp="Content-Length: ";
	strcat(templen,temp);
	strcat(templen,len1);
	//printf("%s\n",templen);
	curl_slist_append(list,templen);
	if(list == NULL)
	{
	   free(postdata);
	   curl_easy_cleanup(curl);
	   return 0;
   }
	
	   /* Now specify the POST data */ 
	
	
	curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
	curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
	
	//CURLOPT_HEADER, 1
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
	
    curl_easy_setopt(curl, CURLOPT_URL, insertVirusApi);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
 
	curl_easy_setopt(curl, CURLOPT_POST, 1L);
	
	/* timeout */
	curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);
	
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
	/* send all data to this function  */ 
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    /* we pass our 'chunk' struct to the callback function */ 
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
    /* some servers don't like requests that are made without a user-agent
    field, so we provide one */ 
    curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);
	
	/* postdata */
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);
 
    /* Perform the request, res will get the return code */ 
    res2 = curl_easy_perform(curl);
    /* Check for errors */ 

	if(res2 != CURLE_OK){
		fprintf(stderr,curl_easy_strerror(res2));
		timeout_times++;
		printf(",reconnected %d times\n",timeout_times);
		if(timeout_times>retrytimes){
			free(postdata);
			curl_easy_cleanup(curl);
			curl_global_cleanup();
			printf("Connected to ACM cloud engine failed,please check the network connection... \n");
			exit(0);
		}
		result = 0;
	}else{
		//char *insertresult =chunk2.memory;
		//printf("%s\n",insertresult);
		result =1;
	}
	
	free(postdata);
	curl_slist_free_all(list); /* free the list again */
  }
  curl_easy_cleanup(curl);
	if(chunk2.memory)
	  free(chunk2.memory);
  curl_global_cleanup();
  return result;
}


int reportHash(char* total_md5,char* section_hash,char* file_path,char *file_size,char *access_time,char *create_time,char *modify_time,char *platform,char* client_ip,char *start_type,char *virus_id,char *token)
{
	CURL *curl;
	CURLcode res2;
	int result=0;
	struct MemoryStruct chunk2;
	chunk2.memory=(char*)malloc(1);
	chunk2.size = 0;    /* no data at this point */ 

	/* In windows, this will init the winsock stuff */ 
	curl_global_init(CURL_GLOBAL_ALL);

	/* get a curl handle */ 
	curl = curl_easy_init();
	struct curl_slist *list = NULL;
	if(curl) 
	{
		int data_size=1024;
		char *postdata = malloc(data_size*(sizeof(char)));
		if(postdata == NULL) return 0;
		memset(postdata,0,data_size*sizeof(char)); //初始化为0
		strcat(postdata,"{\"total_md5\":\"");
		strcat(postdata,total_md5);
		strcat(postdata,"\",\"section_hash\":\"");
		strcat(postdata,section_hash);
		strcat(postdata,"\",\"file_path\":\"");
		strcat(postdata,file_path);
		strcat(postdata,"\",\"file_size\":\"");
		strcat(postdata,file_size);
		strcat(postdata,"\",\"access_time\":\"");
		strcat(postdata,access_time);
		strcat(postdata,"\",\"create_time\":\"");
		strcat(postdata,create_time);
		strcat(postdata,"\",\"modify_time\":\"");
		strcat(postdata,modify_time);
		strcat(postdata,"\",\"platform\":\"");
		strcat(postdata,platform);
		strcat(postdata,"\",\"client_ip\":\"");
		strcat(postdata,client_ip);
		strcat(postdata,"\",\"start_type\":\"");
		strcat(postdata,start_type);
		strcat(postdata,"\",\"virus_id\":\"");
		strcat(postdata,virus_id);
		strcat(postdata,"\",\"token\":\"");
		strcat(postdata,token);
		strcat(postdata,"\"}");
	//	printf("%s\n",postdata);
		
		int datalen=strlen(postdata);
		char len1[1024]={""};
		sprintf(len1,"%d",datalen);
		list = curl_slist_append(NULL, "Content-Type: application/json; charset=UTF-8");
		char templen[1024]={""};
		char *temp="Content-Length: ";
		strcat(templen,temp);
		strcat(templen,len1);
		//printf("%s\n",templen);
		curl_slist_append(list,templen);
		if(list == NULL)
		{
		   free(postdata);
		   curl_easy_cleanup(curl);
		   return 0;
		}
		
		
		
		curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
		curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

		//CURLOPT_HEADER, 1
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
		curl_easy_setopt(curl, CURLOPT_URL, reportHashApi);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		
		curl_easy_setopt(curl, CURLOPT_POST, 1L);

		/* timeout */
		curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);

		curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
		/* send all data to this function  */ 
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
		/* we pass our 'chunk' struct to the callback function */ 
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
		/* some servers don't like requests that are made without a user-agent
		field, so we provide one */ 
		curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);
		
		/* postdata */
		curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);

		/* Perform the request, res will get the return code */ 
		res2 = curl_easy_perform(curl);
		/* Check for errors */ 

		if(res2 != CURLE_OK){
			fprintf(stderr,curl_easy_strerror(res2));
			timeout_times++;
			printf(",reconnected %d times\n",timeout_times);
			if(timeout_times>retrytimes){
				free(postdata);
				curl_easy_cleanup(curl);
				curl_global_cleanup();
				printf("Connected to ACM cloud engine failed,please check the network connection... \n");
				exit(0);
			}
			result=0;
		}else{
			result=1;
		}
	free(postdata);
	}
	curl_easy_cleanup(curl);
    if(chunk2.memory)
      free(chunk2.memory);
	curl_global_cleanup();
}


int scanReport(int infect_count,int clean_count,char* client_ip,double scan_total_time,char * attack_type,char *version,char *platform,char* os_version,char *start_type,char *token){
	CURL *curl;
	CURLcode res2;
	int result=0;
	struct MemoryStruct chunk2;
	chunk2.memory=(char*)malloc(1);
	chunk2.size = 0;    /* no data at this point */ 
	char infected[10]={""};
	f_itoa(infect_count,infected);
	char cleaned[10]={""};
	f_itoa(clean_count,cleaned);
	char totalTime[40]={""};
	int sig=10;
	gcvt(scan_total_time,sig,totalTime);
	//printf("totalTime=%sdec=%d\sign=%d\n",totalTime,dec,sign);
	/* In windows, this will init the winsock stuff */ 
	curl_global_init(CURL_GLOBAL_ALL);

	/* get a curl handle */ 
	curl = curl_easy_init();
	struct curl_slist *list = NULL;
	if(curl) {
		int data_size=1024;
		char *postdata = malloc(data_size*(sizeof(char)));
		if(postdata == NULL) return 0;
		memset(postdata,0,data_size*sizeof(char)); //初始化为0
		strcat(postdata,"{\"infect_count\":");
		strcat(postdata,infected);
		strcat(postdata,",\"clean_count\":");
		strcat(postdata,cleaned);
		strcat(postdata,",\"client_ip\":\"");
		strcat(postdata,client_ip);
		strcat(postdata,"\",\"scan_total_time\":");
		strcat(postdata,totalTime);
		strcat(postdata,",\"attack_type\":\"");
		strcat(postdata,attack_type);
		strcat(postdata,"\",\"version\":\"");
		strcat(postdata,version);
		strcat(postdata,"\",\"platform\":\"");
		strcat(postdata,platform);
		strcat(postdata,"\",\"os_version\":\"");
		strcat(postdata,os_version);
		strcat(postdata,"\",\"start_type\":\"");
		strcat(postdata,start_type);
		strcat(postdata,"\",\"token\":\"");
		strcat(postdata,token);
		strcat(postdata,"\"}");

		//printf("%s\n",postdata);
		
		int datalen=strlen(postdata);
		
		int len1_size=64;
		char *len1 = malloc(len1_size*(sizeof(char)));
		if(len1 == NULL) return 0;
		memset(len1,0,len1_size*sizeof(char)); //初始化为0
		
		//char len1[1024]={""};
		sprintf(len1,"%d",datalen);
		list = curl_slist_append(NULL, "Content-Type: application/json; charset=UTF-8");
		char templen[1024]={""};
		char *temp="Content-Length: ";
		strcat(templen,temp);
		strcat(templen,len1);
		free(len1);
		//printf("%s\n",templen);
		curl_slist_append(list,templen);
		if(list == NULL)
		{
		   free(postdata);
		   curl_easy_cleanup(curl);
		   return 0;
		}
		
		
		curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
		curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

		//CURLOPT_HEADER, 1
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
		
		curl_easy_setopt(curl, CURLOPT_URL, scanReportApi);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		/* Now specify the POST data */ 

		curl_easy_setopt(curl, CURLOPT_POST, 1L);

		/* timeout */
		curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);
		
		curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
		/* send all data to this function  */ 
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
		/* we pass our 'chunk' struct to the callback function */ 
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
		/* some servers don't like requests that are made without a user-agent
		field, so we provide one */ 
		curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);
		/* postdata */
		curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);

		/* Perform the request, res will get the return code */ 
		res2 = curl_easy_perform(curl);
		/* Check for errors */ 

		if(res2 != CURLE_OK){
			fprintf(stderr,curl_easy_strerror(res2));
			timeout_times++;
			printf(",reconnected %d times\n",timeout_times);
			if(timeout_times>retrytimes){
				free(postdata);
				curl_easy_cleanup(curl);
				curl_global_cleanup();
				printf("Connected to ACM cloud engine failed,please check the network connection... \n");
				exit(0);
			}
			result = 0;
		}else{
			//char * temp2 =chunk2.memory;
			//printf("%s\n",temp2);
			result =1;
		}
		free(postdata);
		curl_slist_free_all(list); /* free the list again */
	}
	curl_easy_cleanup(curl);

	if(chunk2.memory)
	  free(chunk2.memory);
	curl_global_cleanup();
	return result;
}


int query_taobaoIpApi(){
	CURL *curl;
	CURLcode res2;
	struct MemoryStruct chunk2;
	chunk2.memory=(char*)malloc(1);
	chunk2.size = 0;    /* no data at this point */ 
	/* In windows, this will init the winsock stuff */ 
	curl_global_init(CURL_GLOBAL_ALL);
	int result=0;
	
	/* get a curl handle */ 
	curl = curl_easy_init();
	if(curl) {
		int data_size=20;
		char *postdata = malloc(data_size*(sizeof(char)));
		if(postdata == NULL) return 0;
		memset(postdata,0,data_size*sizeof(char)); //初始化为0
		strcat(postdata,"ip=myip");

		curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
		curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);


		curl_easy_setopt(curl, CURLOPT_URL, taobaoIpApi);
		//curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
		//curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);


		curl_easy_setopt(curl, CURLOPT_POST, 1L);


		/* timeout */	
		curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);

		curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
		/* send all data to this function  */ 
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
		/* we pass our 'chunk' struct to the callback function */ 
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
		/* some servers don't like requests that are made without a user-agent
		field, so we provide one */ 
		curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);

		curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);
		/* Perform the request, res will get the return code */ 
		res2 = curl_easy_perform(curl);
		/* Check for errors */ 

		if(res2 != CURLE_OK){
			
			fprintf(stderr,curl_easy_strerror(res2));
			timeout_times++;
			printf(",reconnected %d times\n",timeout_times);
			if(timeout_times>retrytimes){
				free(postdata);
				curl_easy_cleanup(curl);
				curl_global_cleanup();
				printf("Connected to TaoBaoApi failed,please check the network connection... \n");
				exit(0);
			}
			result=0;
		}else{
			char * ipText =chunk2.memory;
		//	printf("%s\n",ip);
			
			cJSON * root;
			cJSON * data;
			int state;
			root = cJSON_Parse(ipText); 
			state = cJSON_GetObjectItem(root,"code")->valueint;
			if (state==0)
			{	
				data=cJSON_GetObjectItem(root,"data");
				char *client_ip=cJSON_GetObjectItem(data,"ip")->valuestring;
				strncpy(g_client_ip,client_ip,strlen(client_ip));
				result=1;
			}else{
				//strncpy(g_client_ip,client_ip,strlen(clien_ip));
				result=0;
			}
			cJSON_Delete(root);
	
			} 
		free(postdata);
		//curl_slist_free_all(list); /* free the list again */
	}

	curl_easy_cleanup(curl);
	if(chunk2.memory)
	  free(chunk2.memory);
	curl_global_cleanup();
	return result;
}


int reportJsonBody(char *reportBody,int type)
{
 //setlocale(LC_ALL,".936");
  CURL *curl;
  CURLcode res2;
  int result=0;
  struct MemoryStruct chunk2;
  chunk2.memory=(char*)malloc(1);
  chunk2.size = 0;    /* no data at this point */ 
  char *httpUrl;
  if (type==2)
  {
	  httpUrl=reportHashApi;
  }else if (type==1){
	  httpUrl=insertVirusApi;
  }else if (type==3){
      httpUrl=monitorApi;
  }

  /* In windows, this will init the winsock stuff */ 
  curl_global_init(CURL_GLOBAL_ALL);
 
  /* get a curl handle */ 
  curl = curl_easy_init();
  struct curl_slist *list = NULL;
  if(curl) {
		int data_size=strlen(reportBody)+1;
		char *postdata = (char*)malloc(data_size*(sizeof(char)));
		if(postdata == NULL) return 0;
		memset(postdata,0,data_size*sizeof(char)); //初始化为0
		strcpy(postdata,reportBody);
		int datalen=strlen(postdata);
        //printf("%s\n",postdata);
        
        int len1_size=64;
		char *len1 = malloc(len1_size*(sizeof(char)));
		if(len1 == NULL) return 0;
		memset(len1,0,len1_size*sizeof(char)); //初始化为0

		sprintf(len1,"%d",datalen);
		//printf("%s\n",len1);
		list = curl_slist_append(NULL, "Content-Type: application/json; charset=UTF-8");
		//char templen[64]={""};
		
		char *templen = malloc(len1_size*(sizeof(char)));
		if(templen == NULL) return 0;
		memset(templen,0,len1_size*sizeof(char)); //初始化为0
		
		char *temp="Content-Length: ";
		strcat(templen,temp);
		strcat(templen,len1);
		free(len1);
		//printf("%s\n",templen);
		curl_slist_append(list,templen);
		if(list == NULL) 
		{
			
			free(postdata);
			//free(utf8_postdata);
			curl_easy_cleanup(curl);   
			return 0;
		}
		


		curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);
		curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

		//CURLOPT_HEADER, 1
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
		curl_easy_setopt(curl, CURLOPT_URL, httpUrl);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);

		curl_easy_setopt(curl, CURLOPT_POST, 1L);

		/* timeout */
		curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5);
		curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5);
		/* send all data to this function  */ 
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
		/* we pass our 'chunk' struct to the callback function */ 
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk2);
		/* some servers don't like requests that are made without a user-agent
		field, so we provide one */ 
		curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);

		curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);
		/* Perform the request, res will get the return code */ 
		res2 = curl_easy_perform(curl);
		/* Check for errors */ 

		if(res2 != CURLE_OK){
			fprintf(stderr,curl_easy_strerror(res2));
			timeout_times++;
			printf(",reconnected %d times\n",timeout_times);
			//printLog(mErrorFile,1,timeout_times);
			if(timeout_times>retrytimes){
				
				free(postdata);
				//free(utf8_postdata);
				curl_easy_cleanup(curl);
				curl_global_cleanup();
				printf("Connected to ACM cloud engine failed,please check the network connection... \n");
				exit(0);
			}
			result = 0;
		}else{
			char * temp2 =chunk2.memory;
			result =1;
			//printf("%s\n",temp2);
		}
		free(templen);
		free(postdata);
		//free(utf8_postdata);
		curl_slist_free_all(list); /* free the list again */
  }
  curl_easy_cleanup(curl);

  if(chunk2.memory)
	 free(chunk2.memory);
  curl_global_cleanup();
  return result;
}
int f_itoa(int val, char* buf)
{
	const unsigned int radix = 10;
	char* p;
	unsigned int a; //every digit
	int len;
	char* b; //start of the digit char
	char temp;
	unsigned int u;
	p = buf;
	if (val < 0)
	{
		*p++ = '-';
		val = 0 - val;
	}
	u = (unsigned int)val;
	b = p;
	do{
		a = u % radix;
		u /= radix;
		*p++ = a + '0';
	} while (u > 0);
	len = (int)(p - buf);
	*p-- = 0;
	//swap
	do{
	temp = *p;
	*p = *b;
	*b = temp;
	--p;
	++b;
	} while (b < p);
	return len;
}
